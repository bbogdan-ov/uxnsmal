1 10 255 0xff 0b0 0b11111111 0o377

1* 10* 255* 65535* 0xffff* 0b0* 0b1111111111111111* 0o177777*

"" " " "hey" "string!\n\0"
"\0\a\b\t\n\v\f\r\\\'\""
"Â«\tÑĞ½Ğ¸ĞºĞ¾Ğ´!Â»\n\0"
"å—¨ã€‚"
"ğŸ™ğŸ™"
"Ñ‹"

' ' 'a' '1' '!'
'\0' '\a' '\b' '\t' '\n' '\v' '\f' '\r' '\\' '\'' '\"'

$0 $1 $65535 $0xf $0xffff $0b1 $0o7
$   10$    0xff

add sub mul div inc shift
and or xor
eq neq gth lth
pop swap nip rot dup over sth
load store
input input2 output
add-r add-k add-rk add-kr
input2-r input2-k input2-rk

a symbol foo-bar -sym.bol_hey __ - -._.-__.-
ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»-Ğ½Ğ°-Ñ€ÑƒÑÑĞºĞ¾Ğ¼ Ğ¿Ğ¾Ñ‡ĞµĞ¼Ñƒ-Ğ½ĞµÑ‚
ç”šè‡³åœ¨ä¸­æ–‡ // a single identifier in chinese

&a &symbol &foo-bar &-sym.bol_hey &_ &__ &- &-._.-__.-

@block {}
@hey{ 20 30 add-r pop-r }
a@hey { 0 if { break @hey } }
symbol@foo {
	break@foo
	@bar {
		30 20 add pop
		@baz { symbol break@foo }
		break @bar
	}
	hey
}

loop @exit {}
loop@exit{ help }
loop @exit { break @exit }
loop @exit {
	loop@a{ }
	loop @b {}}

0 if {}
0*if {}
1 if { 20 pop }
1 if { if {}
	else {}
}
if {
	20
	if { foo }
	30 add pop}else{
	break @hey
	if{bar}else{baz}
	&ptr
}
0 if {} elif 1 {}
0 if {} elif 10 30 or {} else {}
0 if {} elif 1 { 10 add pop } else {}
0 if {} elif 1 { 10 add pop } elif 1 {} else {}
0 if {} elif 1 {20} elif 1 0 or {if {} else {10}} else {}

while condition {}
while 1{}
while 1{if{}}
while&a{while b{}if{}else{}}

fun vec ( -> ) {
	// Non-labeled blocks
	{}
	{ 1 2 3 4 }
	{10 20 add pop }
}

-> symbol
->hey ->hello

hello.field
hello[].field
hello[].a.b.c
hello.a.b[].c
hello[].a.b[].c[]

-> hello.field
-> hello[].field
-> hello[].a.b.c
-> hello.a.b[].c
-> hello[].a.b[].c[]

as () as (byte) as (byte short)
as (*byte ^short )
as (byte:hey) as (short:a fun(->) byte:b)

() (a) (hey) (a b _ c _)
:(a) :(_) : (a b)
:(a) b // binding and identifier

include ""
include "hey"
