fun vec ( -> ) {}

// Labeled blocks
fun no-block( byte -- byte ) {
	// ...
}
fun empty-block( byte -- byte ) {
	@block {}
}

fun jumping ( -- ) {
	@exit {
		20
		0 if { pop jump @exit }
		pop
	}
}
fun jumping-stash ( -- ) {
	@exit {
		20 sth
		0 if { pop-r jump @exit }
		pop-r
	}
}
fun jumping-out-of-branching-block ( byte -- byte ) {
	@exit { // branching
		4*
		0 if { pop jump @exit } // branches here

		pop
		jump @exit
		30* // dead code
	}

	10* pop // will execute
}
fun jumping-out-of-branching-loop ( byte -- byte ) {
	// Looping blocks are mostly the same as regular blocks.
	// The only difference is their IR code generation.
	// So i suppose one test for looping block should be enough?..
	loop @exit { // branching
		4*
		0 if { pop jump @exit } // branches here

		pop
		jump @exit
		30* // dead code
	}

	10* pop // will execute
}
fun jumping-out-of-normal-block ( byte -- byte ) {
	@exit {
		pop // pops the inputing `byte`
		jump @exit
		10* // dead code
	}

	10
	123* pop // will execute
}

fun jumping-out-of-parenting-branching-block ( byte -- byte ) {
	@exit { // branching
		30*
		0 if { pop jump @exit } // branches here

		@a { // normal
			pop // pops `30*`

			@b { // normal
				jump @exit
				10* // dead code
			}
		}
		pop // dead code
	}
	123 pop // will execute
}
fun jumping-out-of-parenting-normal-block ( byte -- byte ) {
	@exit {
		@a {
			@b { jump @exit }
			10* // dead code
		}
		5 99 // dead code
	}
	123 pop // will execute
}

fun jumping-out-of-parenting-block-from-braching-block ( byte -- byte ) {
	@exit { // normal
		10

		@branch { // branching
			0 if { jump @branch } // branches here

			pop // pops `10`
			jump @exit
			123* // dead code
		}

		pop // pops `10`, will execute
	}
	123 pop // will execute
}

fun not-so-complex-code( byte -- byte ) {
	0* /* idx */
	loop @exit {
		dup 2* mul /* n */
		@skip {
			/* n */ dup 2* eq if {
				jump @skip
			} else {
				/* n */ dup 8* eq if { jump @skip }
			}

			dup 10* gth if { /* n */ pop jump @exit }
		}
		/* idx n */ pop
		/* idx */ inc
	}
	/* idx */ pop
}

// If-else
fun empty-if ( byte -- byte ) {
	0 if {}
}
fun simple-if ( byte -- byte ) {
	0 if { pop 2 }
}
fun simple-if2 ( byte -- byte ) {
	if {} 8
}
fun empty-if-else ( byte -- byte ) {
	0 if {} else {}
}
fun if-else ( byte -- byte short ) {
	0 if { 30* }
	else { 0xffff* }
}
fun if-else2 ( byte -- byte short ) {
	if   { 1 30* }
	else { 2 0xffff* }
}
fun if-inside-if ( byte -- byte ) {
	dup 10 gth if {
		0 if { 1 add &vec }
		else { 2 mul &vec }
		pop // pops `fun(->)`
	}
}
fun if-inside-else ( byte -- byte fun(->) ) {
	dup 10 gth if {
		3 div
		&vec
	} else {
		0 if { 1 add &vec }
		else { 2 mul &vec }
	}
}
fun if-elif ( -- byte ) {
	'?'
	1 if { pop 'a' } elif 0 { pop 'b' }
}
fun if-elif2 ( -- byte ) {
	'?'
	/**/ 0 if   { pop 'a' }
	elif 1 0 or { pop 'b' }
	elif 0      { pop 'c' }
	elif 1      { pop 'd' }
}
fun if-elif-else ( -- byte ) {
	/**/ 0 if { 'a' }
	elif 1    { 'b' }
	else      { 'c' }
}
fun if-elif-else2 ( -- byte:a ) {
	/**/ 0 if    { 'a' : (a) }
	elif 1 1 and { 'b' : (a) }
	else         { 'c' : (a) }
	(a)
}

// While
fun empty-while ( byte -- byte ) {
	while 0 {}
}
fun simple-while ( byte -- byte ) {
	0 while dup 10 lth {
		dup 2 mul pop
		inc
	}
	pop
}
fun while-while-while ( short -- short ) {
	sth
	0* while dup sth-rk lth {
		inc
	}
	pop-r
}
fun jumping-from-while ( byte -- byte ) {
	0 @break {
		while dup 10 lth {
			dup 5 eq if { jump @break }
			inc
		}
	} pop
}
fun jumping-from-while2 ( byte -- byte ) {
	@break {
		0 while dup 10 lth {
			dup 5 eq if { pop jump @break }
			inc
		} pop
	}
}
fun items-in-while-condition ( *byte:ptr -- ) {
	while (ptr) load-k:(ch) sth-k 0 neq {
		sth-rk (ch) 0x18 output
		(ptr) inc
	}
	pop-r
	(ptr) pop
}

// Return
fun return-from-vec ( -> ) {
	return
	123 45* // dead code
}
fun return-from-vec2 ( -> ) {
	return
	return // dead code
}
fun conditional-return-from-vec-1 ( -- ) {
	30
	0 if { pop return }
	pop
}
fun conditional-return-from-vec-2 ( -> ) {
	2
	0 if {
		pop return
		5 6 // dead code
	}
	4 add pop
}

fun return-from-proc ( byte -- byte ) {
	return
	123* // dead code
}
fun return-from-proc2 ( byte -- byte ) {
	return
	return // dead code
}
fun conditional-return-from-proc-1 ( -- byte ) {
	0 if { 20 return }
	30
}
fun conditional-return-from-proc-2 ( -- byte ) {
	0 if { 1 return }
	0 if {
		69 return
		pop // dead code
	}
	0
}

fun return-from-if-else-1 ( -- byte ) {
	0 if { 40* }
	else { 10 return }

	18* add as (byte byte) pop
}
fun return-from-if-else-2 ( -- byte ) {
	0 if { 10 return }
	else { 40* }

	18* add as (byte byte) pop
}

fun items-in-elif-condition ( byte -- byte ) {
	dup 1 eq if { pop 'a' }
	elif dup 1 eq { pop 'b' }
	elif dup 2 eq 30 { mul }
	else { pop '?' }
}
